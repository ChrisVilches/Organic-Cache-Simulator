{"version":3,"sources":["cache.ts","gui.ts","compiled.js","transpiladorMips.ts"],"names":["isPowerOfTwo","x","numeroCorrecto","num","mostrarError","text","$","procesarDirecciones","direcciones","tablaResultado","validarConfiguracion","crearArregloDirecciones","cache","configurar","blocksize","nblocks","nvias","algoritmo","tipoAsociatividad","addressing","html","transpiladorMips","obtenerCodigoMips","hitCount","missCount","hitRate","bitsIndice","bitsOffset","show","arregloDirecciones","arregloSplit","i","textoProcesado","val","replace","trim","length","split","Array","Number","input_blocksize","input_nblocks","input_nvias","input_asociatividad","input_algoritmo","input_addressing","toString","prop","algoritmoReemplazo","tipoDireccion","cacheEstado","Cache","Object","defineProperty","prototype","get","this","_cacheHitCuenta","enumerable","configurable","_cacheMissCuenta","total","hitPorcentaje","Math","round","_nBlocks","_setSize","_tipoDireccion","BYTE","_blockSize","offsetTotal","numSets","_algoritmoReemplazo","LRU","MRU","RANDOM","WORD","j","numBloque","mapea","sets","palabra","estadohitmiss","resultado","bitsNecesarios","encontrarCantidadDeBitsNecesarias","floor","bloqueEstaEnSet","correrBloqueHastaMasReciente","HIT","agregarBloqueASet","MISS","obtenerFilaCacheActual","dir","max","rellenarBinCerosYDividir","cont","tag","indice","offset","undefined","direccion","numeroAcceso","cacheFila","set","bloque","cuantosBloquesTieneSet","rand","random","hexEncode","tipoDireccionamiento","base","document","ready","title","click"],"mappings":"AACA,YC8CE,SAAAA,cAAsBC,GACrB,KAASA,EAAI,GAAM,GAAMA,EAAI,GAC5BA,GAAK,CACN,OAAa,IAALA,EAIT,QAAAC,gBAAwBC,GACvB,MAAGH,cAAaG,IACR,EADR,OAKD,QAAAC,cAAsBC,GACrBC,EAAE,eAAeD,KAAKA,GAIvB,QAAAE,uBACC,GAAIC,GACAC,CAGJ,IAAIC,uBAAJ,CAMA,GADAF,EAAcG,0BACI,MAAfH,EAEF,WADAJ,cAAa,qCAKdQ,OAAMC,WAAWC,UAAWC,QAASC,MAAOC,UAAWC,kBAAmBC,YAG1EV,EAAiBG,MAAML,oBAAoBC,GAG3CF,EAAE,wBAAwBc,KAAKC,iBAAiBC,kBAAkBd,EAAaW,aAG/Eb,EAAE,wBAAwBc,KAAKX,GAG/BH,EAAE,gBAAgBc,KAAK,eAAeR,MAAMW,SAAS,uBAAuBX,MAAMY,UAAU,2BAA2BZ,MAAMa,QAAQ,aAGrInB,EAAE,kBAAkBc,KAAK,sBAAsBR,MAAMc,WAAW,8BAA8Bd,MAAMe,WAAW,YAG/GrB,EAAE,oBAAoBsB,QAKvB,QAAAjB,2BAEC,GAAIkB,GACAC,EACAC,EACAC,EAA0B1B,EAAE,yBAAyB2B,MAAMC,QAAQ,WAAY,IAMnF,IAHAF,EAAiBA,EAAeG,OAGJ,GAAzBH,EAAeI,OACjB,MAAO,KASR,KANAN,EAAeE,EAAeK,MAAM,KAGpCR,EAAqB,GAAIS,OAAcR,EAAaM,QAGhDL,EAAE,EAAGA,EAAED,EAAaM,OAAQL,IAC/BF,EAAmBE,GAAKQ,OAAOT,EAAaC,GAI7C,OAAOF,GAIR,QAAAnB,wBAIC,GAAI8B,GAA2BD,OAAOjC,EAAE,qBAAqB2B,OACzDQ,EAAyBF,OAAOjC,EAAE,mBAAmB2B,OACrDS,EAAuBH,OAAOjC,EAAE,iBAAiB2B,OAEjDU,EAA+BrC,EAAE,6BAA6B2B,MAC9DW,EAA2BtC,EAAE,qBAAqB2B,MAClDY,EAA4BvC,EAAE,sBAAsB2B,KAWxD,OARGS,GAAcD,IAChBnC,EAAE,iBAAiB2B,IAAIQ,EAAcK,YACrCJ,EAAcD,GAMXvC,eAAesC,GAIftC,eAAeuC,GAIK,MAArBvB,mBAA8BhB,eAAewC,GAKpB,MAAvBC,GAAsD,MAAvBA,GAAsD,MAAvBA,GAClEvC,aAAa,8BACN,GAGgB,OAAnBwC,GAA+C,OAAnBA,GAA+C,UAAnBA,GAC5DxC,aAAa,0BACN,GAGiB,KAApByC,GAA+C,KAApBA,GAC/BzC,aAAa,mCACN,IAMRU,UAAY0B,EACZzB,QAAU0B,EACVzB,MAAQ0B,EACRxB,kBAAoByB,EACpB1B,UAAY2B,EACZzB,WAAa0B,EAIW,MAArB3B,mBACFZ,EAAE,iBAAiByC,KAAK,YAAY,GACpCzC,EAAE,qBAAqByC,KAAK,YAAY,GAExC/B,MAAQ,GAEsB,MAArBE,mBACTZ,EAAE,iBAAiByC,KAAK,YAAY,GACpCzC,EAAE,qBAAqByC,KAAK,YAAY,IAIV,MAArB7B,oBACTZ,EAAE,iBAAiByC,KAAK,YAAY,GACpCzC,EAAE,qBAAqByC,KAAK,YAAY,GAExC/B,MAAQD,SAITT,EAAE,iBAAiB2B,IAAIjB,MAAM8B,YAG7BxC,EAAE,eAAeD,MAAMU,QAAUC,OAAO8B,YACxCxC,EAAE,mBAAmBD,KAAMU,QAAUD,UAAY,EAAK,WAAYC,QAAUD,UAAW,cAEvFV,aAAa,KAEN,IA3DNA,aAAa,0EACN,IALPA,aAAa,6EACN,IALPA,aAAa,4EACN,GD3JX,GAAK4C,qBAAL,SAAKA,GACHA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,OAAA,GAAA,UAHGA,qBAAAA,uBAML,IAAKC,gBAAL,SAAKA,GACJA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,QAFIA,gBAAAA,kBAKL,IAAKC,cAAL,SAAKA,GACJA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,KAAA,GAAA,QAFIA,cAAAA,gBAML,IAAAC,OAAA,WAaC,QAAAA,MA6XD,MAxXCC,QAAAC,eAAIF,EAAAG,UAAA,YEhBGC,IFgBP,WACC,MAAOC,MAAKC,iBEdNC,YAAY,EACZC,cAAc,IFgBrBP,OAAAC,eAAIF,EAAAG,UAAA,aEbGC,IFaP,WACC,MAAOC,MAAKI,kBEXNF,YAAY,EACZC,cAAc,IFarBP,OAAAC,eAAIF,EAAAG,UAAA,WEVGC,IFUP,WACC,GAAIM,GACAC,CAGJ,OAFAD,GAAQL,KAAKjC,SAAWiC,KAAKhC,UAC7BsC,EAAgBN,KAAKjC,SAASsC,EACvBE,KAAKC,MAAoB,IAAdF,GAAqB,KERjCJ,YAAY,EACZC,cAAc,IFWrBP,OAAAC,eAAIF,EAAAG,UAAA,WERGC,IFQP,WACC,MAAOC,MAAKS,SAAST,KAAKU,UENpBR,YAAY,EACZC,cAAc,IFWrBP,OAAAC,eAAIF,EAAAG,UAAA,eELGC,IFKP,WACC,MAAGC,MAAKW,gBAAkBlB,cAAcmB,KACd,EAAlBZ,KAAKa,WAENb,KAAKa,YEHNX,YAAY,EACZC,cAAc,IFOrBP,OAAAC,eAAIF,EAAAG,UAAA,cEHGC,IFGP,WAIC,MAAOC,MAAKc,YAAYxB,SAAS,GAAGV,OAAS,GEDvCsB,YAAY,EACZC,cAAc,IFIrBP,OAAAC,eAAIF,EAAAG,UAAA,cEAGC,IFAP,WACC,MAAOC,MAAKe,QAAQzB,SAAS,GAAGV,OAAS,GEEnCsB,YAAY,EACZC,cAAc,IFEdR,EAAAG,UAAAzC,WAAP,SAAkBC,EAAoBC,EAAkBC,EAAgBC,EAAoBC,EAA4BC,GACvHqC,KAAKa,WAAavD,EAClB0C,KAAKS,SAAWlD,EAGA,OAAbE,EAAoBuC,KAAKgB,oBAAsBxB,mBAAmByB,IAChD,OAAbxD,EAAoBuC,KAAKgB,oBAAsBxB,mBAAmB0B,IACrD,UAAbzD,IAAuBuC,KAAKgB,oBAAsBxB,mBAAmB2B,QAG5D,KAAdxD,EAAmBqC,KAAKW,eAAiBlB,cAAcmB,KACrDZ,KAAKW,eAAiBlB,cAAc2B,KAGjB,MAArB1D,EACFsC,KAAKU,SAAW,EAGY,MAArBhD,EACPsC,KAAKU,SAAWlD,EAGY,MAArBE,IACPsC,KAAKU,SAAWV,KAAKS,WAKhBd,EAAAG,UAAA/C,oBAAP,SAA2BC,GAC1B,GAAIuB,GACA8C,EAQAC,EAGAC,EAGAC,EAIAC,EAGAC,EApBAC,EAAqB,GAIrBC,EAA0B5B,KAAK6B,kCAAkC7E,EA6BrE,KAVAgD,KAAKC,gBAAkB,EACvBD,KAAKI,iBAAmB,EAKxBoB,EAAO,GAAI1C,OAAMkB,KAAKe,SAIjBxC,EAAE,EAAGA,EAAEyB,KAAKe,QAASxC,IACzBiD,EAAKjD,GAAK,GAAIO,OAAMkB,KAAKU,SAK1B,KAAInC,EAAE,EAAGA,EAAEyB,KAAKe,QAASxC,IACxB,IAAI8C,EAAE,EAAGA,EAAErB,KAAKU,SAAUW,IACzBG,EAAKjD,GAAG8C,GAAK,EAgBf,KAXAM,EAAY,oCAIZA,GAAa,OACbA,GAAa,2BACbA,GAAa,2BACbA,GAAa,mCACbA,GAAa,mEACbA,GAAa,kCAETpD,EAAE,EAAGA,EAAEyB,KAAKe,QAASxC,IACxBoD,GAAa,WAAWpD,EAAE,OAO3B,KALAoD,GAAa,QAKTpD,EAAE,EAAGA,EAAEvB,EAAY4B,OAAQL,IAE9BkD,EAAUzE,EAAYuB,GAGtB+C,EAAYf,KAAKuB,MAAML,EAAQzB,KAAKc,aAGpCS,EAAQD,EAAYtB,KAAKe,QAGtBf,KAAK+B,gBAAgBP,EAAKD,GAAQD,IAGpCtB,KAAKgC,6BAA6BR,EAAKD,GAAQD,GAC/CtB,KAAKC,kBACLyB,EAAgBhC,YAAYuC,MAI5BjC,KAAKkC,kBAAkBV,EAAKD,GAAQD,GACpCtB,KAAKI,mBACLsB,EAAgBhC,YAAYyC,MAG7BR,GAAa3B,KAAKoC,uBAAuBZ,EAAME,EAAe1E,EAAYuB,GAAI+C,EAAW/C,EAAGqD,EAK7F,OAFAD,IAAa,YAQNhC,EAAAG,UAAA+B,kCAAR,SAA0CQ,GACzC,GACI9D,GADA+D,EAAe,CAGnB,KAAI/D,EAAE,EAAGA,EAAE8D,EAAIzD,OAAQL,IACnB8D,EAAI9D,GAAK+D,IACXA,EAAMD,EAAI9D,GAIZ,OAAO+D,GAAIhD,SAAS,GAAGV,QAMhBe,EAAAG,UAAAyC,yBAAR,SAAiC5F,EAAc2F,GAS9C,IARA,GAII/D,GACAiE,EALAb,EAAqBhF,EAAI2C,SAAS,GAClCmD,EAAe,GACfC,EAAkB,GAClBC,EAAkB,GAKhBhB,EAAU/C,OAAS0D,GACxBX,EAAY,IAAIA,CASjB,KAAIa,EAAK,EAAGjE,EAAEoD,EAAU/C,OAAO,EAAG4D,EAAOxC,KAAK7B,WAAYqE,IAAQjE,IAEhEoE,EADkBC,QAAhBjB,EAAUpD,GACH,IAAMoE,EAENhB,EAAUpD,GAAKoE,CAK1B,KAAIH,EAAK,EAAGA,EAAOxC,KAAK9B,WAAYsE,IAAQjE,IAE1CmE,EADkBE,QAAhBjB,EAAUpD,GACH,IAAMmE,EAENf,EAAUpD,GAAKmE,CAK1B,MAAMnE,EAAI,GAAIA,IAEZkE,EADkBG,QAAhBjB,EAAUpD,GACN,IAAMkE,EAENd,EAAUpD,GAAKkE,CASvB,OAJiB,IAAdA,EAAI7D,SACN6D,EAAM,QAGAA,EAAM,SAAWC,EAAS,SAAWC,GAKrChD,EAAAG,UAAAsC,uBAAR,SAA+BZ,EAAME,EAA6BmB,EAAoBvB,EAAoBwB,EAAuBlB,GAChI,GAAIrD,GACA8C,EACA0B,CAuBJ,KAnBCA,EADErB,GAAiBhC,YAAYuC,IACnB,6BAEA,8BAIbc,GAAa,QAAQD,EAAa,GAAG,QAGrCC,GAAa,OAAOF,EAAU,QAG9BE,GAAa,OAAO/C,KAAKuC,yBAAyBM,EAAWjB,GAAgB,QAG7EmB,GAAa,OAAOzB,EAAU,QAI1B/C,EAAE,EAAGA,EAAEyB,KAAKe,QAASxC,IAAI,CAE5B,IADAwE,GAAa,OACT1B,EAAE,EAAGA,EAAErB,KAAKU,SAAUW,IACR,IAAdG,EAAKjD,GAAG8C,KACV0B,GAAavB,EAAKjD,GAAG8C,GAAG,IAG1B0B,IAAa,QAKd,MAFAA,IAAa,SAONpD,EAAAG,UAAAkC,6BAAR,SAAqCgB,EAAKC,GACzC,GAAI1E,GACA2E,EAAkClD,KAAKkD,uBAAuBF,EAGlE,KADAzE,EAAI,IACO,CACV,GAAGyE,EAAIzE,IAAM0E,EAAQ,KACrB1E,KAGD,KAAQ2E,EAAuB,EAAzB3E,EAA4BA,IACjCyE,EAAIzE,GAAKyE,EAAIzE,EAAE,EAGhByE,GAAIE,EAAuB,GAAKD,GAIzBtD,EAAAG,UAAAoD,uBAAR,SAA+BF,GAC9B,GAAIrB,GACApD,CAGJ,KAFAoD,EAAY,EAERpD,EAAE,EAAGA,EAAEyB,KAAKU,UACF,IAAVsC,EAAIzE,GADkBA,IAIxBoD,GAIF,OAAOA,IAKAhC,EAAAG,UAAAoC,kBAAR,SAA0Bc,EAAKC,GAE9B,GAAIC,GAAkClD,KAAKkD,uBAAuBF,EAIlE,IAAGE,EAAyBlD,KAAKU,SAEhC,YADAsC,EAAIE,GAA0BD,EAM/B,QAAOjD,KAAKgB,qBACX,IAAKxB,oBAAmByB,IAEvB,GAAI1C,EACJ,KAAIA,EAAE,EAAGA,EAAEyB,KAAKU,SAAS,EAAGnC,IAC3ByE,EAAIzE,GAAKyE,EAAIzE,EAAE,EAGhByE,GAAIhD,KAAKU,SAAS,GAAKuC,CACxB,MAEA,KAAKzD,oBAAmB0B,IAEvB8B,EAAIhD,KAAKU,SAAS,GAAKuC,CACxB,MAEA,KAAKzD,oBAAmB2B,OACvB,GAAIgC,GAAO5C,KAAKuB,MAAMvB,KAAK6C,SAASpD,KAAKU,SACzCsC,GAAIG,GAAQF,IAMPtD,EAAAG,UAAAiC,gBAAR,SAAwBiB,EAAKC,GAC5B,GAAI1E,EACJ,KAAIA,EAAE,EAAGA,EAAEyB,KAAKU,SAAUnC,IACzB,GAAGyE,EAAIzE,IAAM0E,EACZ,OAAO,CAGT,QAAO,GAGTtD,KG7ZU9B,kBAAV,SAAUA,GACT,QAAAwF,GAA0B1G,GACzB,MAAO,KAAKA,EAAI2C,SAAS,IAIvB,QAAAxB,GAAkCd,EAAsBsG,GAC1D,GAAI/E,GACAgF,EAAgB,UAChB5B,EAAqB,EAEzB,IAA2B,KAAxB2B,EACF,IAAI/E,EAAE,EAAGA,EAAEvB,EAAY4B,OAAQL,IAC9BoD,GAAa,WAAW0B,EAAUE,EAAKvG,EAAYuB,IAAI,SAExD,KAAIA,EAAE,EAAGA,EAAEvB,EAAY4B,OAAQL,IAC9BoD,GAAa,WAAW0B,EAAUE,EAAqB,EAAfvG,EAAYuB,IAAO,IAG7D,OADAzB,GAAE,wBAAwBc,KAAK+D,GACxBA,EAlBQ9D,EAAAwF,UAASA,EAKNxF,EAAAC,kBAAiBA,GAN3BD,mBAAAA,qBFGR,IAAIP,WACAC,QACAC,MAEAC,UACAC,kBACAC,WAEAP,KASJN,GAAE0G,UAAUC,MAAM,WAEjBD,SAASE,MAAQ,0BAIjB5G,EAAE,qBAAqB2B,IAAI,GAAIa,YAC/BxC,EAAE,mBAAmB2B,IAAI,IAAKa,YAC9BxC,EAAE,iBAAiB2B,IAAI,GAAIa,YAC3BpC,uBAEAE,MAAQ,GAAIuC,OAKZ7C,EAAE,iBAAiB6G,MAAM,WACxB5G","file":"compiled.js","sourcesContent":["/// <reference path=\"jquery.d.ts\"/>\n\"use strict\";\n\nenum algoritmoReemplazo{\n\t\tLRU,\n\t\tMRU,\n\t\tRANDOM\n}\n\nenum tipoDireccion{\n\tBYTE,\n\tWORD\n}\n\nenum cacheEstado{\n\tHIT,\n\tMISS\n}\n\n\nclass Cache{\t\n\n\tprivate _blockSize : number;\n\tprivate _nBlocks : number;\t\n\tprivate _setSize : number;\n\t\n\tprivate _algoritmoReemplazo : algoritmoReemplazo;\n\tprivate _tipoDireccion : tipoDireccion;\n\t\n\tprivate _cacheHitCuenta : number;\n\tprivate _cacheMissCuenta : number;\n\t\n\t\n\tconstructor(){\n\t\t\n\n\t}\n\t\n\tget hitCount() : number{\n\t\treturn this._cacheHitCuenta;\n\t}\n\t\n\tget missCount() : number{\n\t\treturn this._cacheMissCuenta;\n\t}\n\n\tget hitRate() : number{\n\t\tvar total : number;\n\t\tvar hitPorcentaje : number;\n\t\ttotal = this.hitCount + this.missCount;\n\t\thitPorcentaje = this.hitCount/total;\n\t\treturn Math.round(hitPorcentaje*10000)/100;\n\t}\n\t\n\t\n\tget numSets() : number{\n\t\treturn this._nBlocks/this._setSize;\n\t}\n\t\n\t// No entrega el numbero de bits que tiene el offset, si no\n\t// el numero por el cual el numero debe ser dividido, para encontrar\n\t// tag + indice (eliminar el offset)\n\tget offsetTotal() : number{\n\t\tif(this._tipoDireccion == tipoDireccion.BYTE){\n\t\t\treturn this._blockSize * 4;\n\t\t}\n\t\treturn this._blockSize;\n\t}\n\t\n\t\n\t// Numero de bits del offset\n\tget bitsOffset() : number{\n\t\t// Es necesario restarle 1 porque, por ejemplo si hay 4 palabras por bloque\n\t\t// el numero binario es 100, es decir 4. Pero se pueden hacer cuatro combinaciones\n\t\t// con solo 2 bits, 00 01 10 11, por lo tanto no es necesario 3 bits, si no 2.\n\t\treturn this.offsetTotal.toString(2).length - 1;\n\t}\n\t\t\n\t// Obtiene la cantidad de bits necesarias para el indice\n\tget bitsIndice() : number{\n\t\treturn this.numSets.toString(2).length - 1;\n\t}\n\t\n\t\n\t// Interfaz con la GUI, recibe la configuracion\n\tpublic configurar(blocksize : number, nblocks : number, nvias : number, algoritmo : string, tipoAsociatividad : string, addressing : string) : void{\n\t\tthis._blockSize = blocksize;\n\t\tthis._nBlocks = nblocks;\n\t\t\n\t\t// Algoritmo\n\t\tif(algoritmo == \"lru\") this._algoritmoReemplazo = algoritmoReemplazo.LRU;\n\t\telse if(algoritmo == \"mru\") this._algoritmoReemplazo = algoritmoReemplazo.MRU;\n\t\telse if(algoritmo == \"random\") this._algoritmoReemplazo = algoritmoReemplazo.RANDOM;\n\t\t\n\t\t// Addressing\n\t\tif(addressing == \"b\") this._tipoDireccion = tipoDireccion.BYTE;\n\t\telse this._tipoDireccion = tipoDireccion.WORD;\n\t\t\n\t\t// Mapeo directo\n\t\tif(tipoAsociatividad == \"md\") {\n\t\t\tthis._setSize = 1;\n\t\t} \n\t\t// Set asociativo\n\t\telse if(tipoAsociatividad == \"sa\") {\n\t\t\tthis._setSize = nvias;\n\t\t} \n\t\t// Full asociativo\n\t\telse if(tipoAsociatividad == \"fa\") {\n\t\t\tthis._setSize = this._nBlocks;\n\t\t}  \t\t\t\n\t}\n\t\n\t\n\tpublic procesarDirecciones(direcciones : number[]) : string{\n\t\tvar i : number;\n\t\tvar j : number;\n\t\tvar resultado : string = \"\";\n\t\t\n\t\t// Numero de bits necesarios para poder mostrar por pantalla\n\t\t// la direccion mas larga del conjunto\n\t\tvar bitsNecesarios : number = this.encontrarCantidadDeBitsNecesarias(direcciones);\t\n\t\t\t\t\n\t\t// Numero de bloque de la direccion leida\n\t\tvar numBloque : number;\n\t\t\n\t\t// Hacia donde mapea el bloque leido\n\t\tvar mapea : number;\n\t\t\n\t\t// Aca se almacena la tabla\n\t\tvar sets;\n\t\t\n\t\t// Obtener la palabra leida (si es por WORD, es la misma direccion)\n\t\t// si es por BYTE hay que cambiarlo\n\t\tvar palabra : number;\n\t\t\n\t\t// El estado del cache, hit o miss?\n\t\tvar estadohitmiss : cacheEstado;\n\t\t\n\t\t// Reiniciar el cache\n\t\tthis._cacheHitCuenta = 0;\n\t\tthis._cacheMissCuenta = 0;\n\t\t\n\n\t\t// Crear sets\n\t\t\n\t\tsets = new Array(this.numSets);\n\t\t\n\t\t// Cada set tiene SET SIZE bloques\n\t\t\n\t\tfor (i=0; i<this.numSets; i++){\n\t\t\tsets[i] = new Array(this._setSize);\n\t\t}\t\t\n\t\t\n\t\t// Hacer que sean todos -1\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tfor(j=0; j<this._setSize; j++){\n\t\t\t\tsets[i][j] = -1;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t\t\n\t\tresultado = \"<table class=\\\"tablaCacheHitMiss\\\">\";\n\t\t\n\t\t// Crear las cabeceras de la tabla\n\t\t\n\t\tresultado += \"<tr>\";\n\t\tresultado += \"<th class=\\\"noset\\\"> </th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">#</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">direccion</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">binario <small>(tag indice offset)</small</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">bloque #</th>\";\t\t\t\t\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tresultado += \"<th>set \"+i+\"</th>\";\n\t\t}\n\t\tresultado += \"</tr>\";\t\n\t\t\n\t\t\t\n\t\t// Leer todas las direcciones\n\t\t\n\t\tfor(i=0; i<direcciones.length; i++){\t\t\n\t\t\t\n\t\t\tpalabra = direcciones[i];\n\t\t\t\n\t\t\t// La palabra se encuentra en el bloque\n\t\t\tnumBloque = Math.floor(palabra/this.offsetTotal);\n\t\t\t\n\t\t\t// El bloque mapea a\n\t\t\tmapea = numBloque % this.numSets;\n\n\t\t\t// Ver si el bloque ya esta en cache\n\t\t\tif(this.bloqueEstaEnSet(sets[mapea], numBloque)){\n\t\t\t\t// Esta en cache\n\t\t\t\t// Hay que reordenar\n\t\t\t\tthis.correrBloqueHastaMasReciente(sets[mapea], numBloque);\n\t\t\t\tthis._cacheHitCuenta++;\n\t\t\t\testadohitmiss = cacheEstado.HIT;\n\t\t\t} else {\n\t\t\t\t// No esta en cache\n\t\t\t\t// Lo agrega siempre al final\n\t\t\t\tthis.agregarBloqueASet(sets[mapea], numBloque);\n\t\t\t\tthis._cacheMissCuenta++;\n\t\t\t\testadohitmiss = cacheEstado.MISS;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tresultado += this.obtenerFilaCacheActual(sets, estadohitmiss, direcciones[i], numBloque, i, bitsNecesarios);\n\t\t}\t\t\n\t\t\n\t\tresultado += \"</table>\";\n\t\t\n\t\treturn resultado;\n\t}\n\t\n\t\n\t// Dada un arreglo de direcciones, encuentra el numero de bits necesarios\n\t// para poder representar en binario, la direccion mas larga del arreglo\n\tprivate encontrarCantidadDeBitsNecesarias(dir : number[]) : number{\n\t\tvar max : number = 0;\n\t\tvar i : number;\n\t\t\n\t\tfor(i=0; i<dir.length; i++){\n\t\t\tif(dir[i] > max){\n\t\t\t\tmax = dir[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max.toString(2).length;\n\t\t\n\t}\n\t\n\t// Dado una direccion numerica, la convierte en binario, y ademas\n\t// separa la string (usando espacios) en tag, indice y offset\n\tprivate rellenarBinCerosYDividir(num : number, max : number) : string{\n\t\tvar resultado : string = num.toString(2);\n\t\tvar tag : string = \"\";\n\t\tvar indice : string = \"\";\n\t\tvar offset : string = \"\";\n\t\tvar i : number;\n\t\tvar cont : number;\n\t\t\n\t\t// Agregar ceros hasta que se complete el tamano esperado\n\t\twhile(resultado.length < max){\n\t\t\tresultado = \"0\"+resultado;\n\t\t}\n\t\t\n\t\t// Ir agregando los digitos. En algunos casos podria ser que la\n\t\t// string mas larga, tiene menos digitos que los digitos del\n\t\t// offset e indice, en ese caso serian puros undefined,\n\t\t// por eso en caso que sea undefined, le agrego un 0.\t\t\n\t\t\n\t\t// Obtener el offset\n\t\tfor(cont=0, i=resultado.length-1; cont < this.bitsOffset; cont++, i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\toffset = \"0\" + offset;\n\t\t\t} else {\n\t\t\t\toffset = resultado[i] + offset;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t// Obtener el indice\n\t\tfor(cont=0; cont < this.bitsIndice; cont++, i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\tindice = \"0\" + indice;\n\t\t\t} else {\n\t\t\t\tindice = resultado[i] + indice;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t// Obtener el tag\n\t\tfor(; i > -1; i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\ttag = \"0\" + tag;\n\t\t\t} else {\n\t\t\t\ttag = resultado[i] + tag;\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// Si el tag no tiene digitos, entonces colocarle algunos ceros\n\t\tif(tag.length == 0) {\n\t\t\ttag = \"0000\";\n\t\t}\n\t\t\n\t\treturn tag + \"&nbsp;\" + indice + \"&nbsp;\" + offset;\t\n\t}\n\t\n\t\n\t// Entrega el estado de cache en un determinado momento\n\tprivate obtenerFilaCacheActual(sets, estadohitmiss : cacheEstado, direccion : number, numBloque : number, numeroAcceso : number, bitsNecesarios : number) : string{\n\t\tvar i:number;\n\t\tvar j:number;\n\t\tvar cacheFila:string;\t\t\n\t\t\n\t\t// Agregar el estado (hit/miss)\t\t\t\n\t\tif(estadohitmiss == cacheEstado.HIT){\n\t\t\tcacheFila = \"<tr class=\\\"hit\\\"><td>H</td>\";\n\t\t} else {\n\t\t\tcacheFila = \"<tr class=\\\"miss\\\"><td>M</td>\";\n\t\t}\n\t\t\t\n\t\t// Numero de acceso\n\t\tcacheFila += \"<td>\"+(numeroAcceso+1)+\"</td>\";\n\t\t\t\n\t\t// Colocar la direccion (decimal)\n\t\tcacheFila += \"<td>\"+direccion+\"</td>\";\n\t\t\n\t\t// Direccion (binario)\n\t\tcacheFila += \"<td>\"+this.rellenarBinCerosYDividir(direccion, bitsNecesarios)+\"</td>\";\n\t\t\n\t\t// A que bloque pertenece\n\t\tcacheFila += \"<td>\"+numBloque+\"</td>\";\n\t\t\n\t\t// set[num set][num bloque]\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tcacheFila += \"<td>\";\n\t\t\tfor(j=0; j<this._setSize; j++){\n\t\t\t\tif(sets[i][j] != -1){\n\t\t\t\t\tcacheFila += sets[i][j]+\" \";\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tcacheFila += \"</td>\";\n\t\t}\n\t\t\n\t\tcacheFila += \"</tr>\";\n\t\t\n\t\treturn cacheFila;\n\t}\n\t\n\n\t\n\tprivate correrBloqueHastaMasReciente(set, bloque : number) : void{\n\t\tvar i : number;\n\t\tvar cuantosBloquesTieneSet : number = this.cuantosBloquesTieneSet(set);\n\t\t\n\t\ti = 0;\n\t\twhile(true){\t\t\t\n\t\t\tif(set[i] == bloque) break;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(; i<cuantosBloquesTieneSet-1; i++){\n\t\t\tset[i] = set[i+1];\n\t\t}\n\t\t// Agregar bloque nuevo\n\t\tset[cuantosBloquesTieneSet-1] = bloque;\t\t\n\t}\n\t\n\t\n\tprivate cuantosBloquesTieneSet(set):number{\n\t\tvar resultado : number;\n\t\tvar i : number;\n\t\tresultado = 0;\n\t\t\n\t\tfor(i=0; i<this._setSize; i++){\n\t\t\tif(set[i] == -1){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tresultado++;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treturn resultado;\n\t}\n\t\n\t\n\t// Lo agrega segun algoritmo\n\tprivate agregarBloqueASet(set, bloque : number) : void{\n\t\t\n\t\tvar cuantosBloquesTieneSet : number = this.cuantosBloquesTieneSet(set);\n\t\t\n\t\t// Si no esta lleno el set, simplemente se agrega al final\n\t\t\n\t\tif(cuantosBloquesTieneSet < this._setSize){\n\t\t\tset[cuantosBloquesTieneSet] = bloque;\n\t\t\treturn;\t\n\t\t}\n\t\t\n\t\t// Esta lleno\n\n\t\tswitch(this._algoritmoReemplazo){\n\t\t\tcase algoritmoReemplazo.LRU:\n\t\t\t\t// El primero es el mas antiguo\n\t\t\t\tvar i : number;\n\t\t\t\tfor(i=0; i<this._setSize-1; i++){\n\t\t\t\t\tset[i] = set[i+1];\n\t\t\t\t}\n\t\t\t\t// Agregar bloque nuevo al final\n\t\t\t\tset[this._setSize-1] = bloque;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase algoritmoReemplazo.MRU:\n\t\t\t\t// El ultimo es el mas reciente\n\t\t\t\tset[this._setSize-1] = bloque;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase algoritmoReemplazo.RANDOM:\n\t\t\t\tvar rand = Math.floor(Math.random()*this._setSize);\n\t\t\t\tset[rand] = bloque;\t\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n\tprivate bloqueEstaEnSet(set, bloque : number):Boolean{\n\t\tvar i : number;\n\t\tfor(i=0; i<this._setSize; i++){\n\t\t\tif(set[i] == bloque){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n}","\t\t/// <reference path=\"jquery.d.ts\"/>\n\t\t/// <reference path=\"cache.ts\"/>\n        /// <reference path=\"transpiladorMips.ts\"/>\n\n\t\tvar blocksize : number;\n\t\tvar nblocks : number;\n\t\tvar nvias : number;\n\t\t\n\t\tvar algoritmo : string;\n\t\tvar tipoAsociatividad : string;\n\t\tvar addressing : string;\n\t\t\n\t\tvar cache : Cache;\n\t\t\n\t\t\n\t\t/*\n\t\t*\n\t\t*\tSe ejecuta al cargar la pagina\n\t\t*\n\t\t*/\n\t\t\n\t\t$(document).ready(function(){\n\t\t\t\n\t\t\tdocument.title = \"Organic Cache Simulator\";\n\n\t\t\t// Configuracion inicial\n\t\t\t\n\t\t\t$(\"#config_blocksize\").val((4).toString());\n\t\t\t$(\"#config_nblocks\").val((16).toString());\n\t\t\t$(\"#config_nvias\").val((4).toString());\t\n\t\t\tvalidarConfiguracion();\t\n\t\t\t\n\t\t\tcache = new Cache();\t\n\t\t\t\n\t\t\t\n\t\t\t// Evento mouse\n\t\t\t\n\t\t\t$(\"#btn_procesar\").click(function(){\t\n\t\t\t\tprocesarDirecciones();\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t\t\t\n\t\t});\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfunction isPowerOfTwo(x : number) : Boolean{\n\t\t\twhile (((x % 2) == 0) && x > 1)\n\t\t\t\tx /= 2;\n\t\t\treturn (x == 1);\n\t\t}\n\t\t\n\t\t\n\t\tfunction numeroCorrecto(num : number) : Boolean{\n\t\t\tif(isPowerOfTwo(num))\n\t\t\t\treturn true;\n\t\t}\t\t\n\t\t\n\t\t\n\t\tfunction mostrarError(text : string) : void{\n\t\t\t$(\"#span_error\").text(text);\n\t\t}\t\t\n\t\t\n\t\t\n\t\tfunction procesarDirecciones() : void{\n\t\t\tvar direcciones : number[];\n\t\t\tvar tablaResultado : string;\n\t\t\t\t\t\t\n\t\t\t// Primero realizar las validaciones de la configuracion de cache\n\t\t\tif(!validarConfiguracion()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Validar direcciones\n\t\t\tdirecciones = crearArregloDirecciones();\t\t\t\n\t\t\tif(direcciones == null){\n\t\t\t\tmostrarError(\"Ingresar direcciones correctamente\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Configurar cache\n\t\t\tcache.configurar(blocksize, nblocks, nvias, algoritmo, tipoAsociatividad, addressing);\t\t\t\n\t\t\t\n\t\t\t// Obtener tabla cronologica de resultados\n\t\t\ttablaResultado = cache.procesarDirecciones(direcciones);\n\t\t\t\n\t\t\t// Obtener codigo mars\t\t\t\n\t\t\t$(\"#textarea_codigomars\").html(transpiladorMips.obtenerCodigoMips(direcciones, addressing));\n\t\t\t\n\t\t\t// Mostrar tabla\n\t\t\t$(\"#tablaCacheResultado\").html(tablaResultado);\n\t\t\t\n\t\t\t// Mostrar cuenta hit y miss\n\t\t\t$(\"#hitMissRate\").html(\"<p>Hits: <b>\"+cache.hitCount+\"</b></p><p>Miss: <b>\"+cache.missCount+\"</b></p><p>Hit rate: <b>\"+cache.hitRate+\"%</b></p>\");\n\t\t\t\n\t\t\t// Muestra cuantos bits necesita el indice y offset.\n\t\t\t$(\"#bitsDireccion\").html(\"<p>Bits indice: <b>\"+cache.bitsIndice+\"</b></p><p>Bits offset: <b>\"+cache.bitsOffset+\"</b></p>\");\n\t\t\t\n\t\t\t// Desocultar resultados\n\t\t\t$(\"#todosResultados\").show();\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfunction crearArregloDirecciones() : number[]{\t\n\t\t\t// Todo lo que no es numero, transformarlo a espacio\n\t\t\tvar arregloDirecciones : number[];\n\t\t\tvar arregloSplit : string[];\n\t\t\tvar i : number;\n\t\t\tvar textoProcesado : string = $(\"#textarea_direcciones\").val().replace(/[^0-9]+/g, \" \");\n\t\t\t\n\t\t\t// Eliminar los espacios de sobra\n\t\t\ttextoProcesado = textoProcesado.trim();\n\t\t\t\n\t\t\t// Si no hay texto, retornar null\n\t\t\tif(textoProcesado.length == 0){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tarregloSplit = textoProcesado.split(\" \");\n\t\t\t\n\t\t\t// Crear arreglo numerico\n\t\t\tarregloDirecciones = new Array<number>(arregloSplit.length);\n\t\t\t\n\t\t\t// Convertir a numeros\n\t\t\tfor(i=0; i<arregloSplit.length; i++){\n\t\t\t\tarregloDirecciones[i] = Number(arregloSplit[i]);\n\t\t\t}\n\t\t\t\n\t\t\t// Si hay texto, retornar el arreglo de numeros\n\t\t\treturn arregloDirecciones\n\t\t}\n\t\t\n\t\t\n\t\tfunction validarConfiguracion() : Boolean{\t\t\t\n\t\t\t\t\t\t\n\t\t\t// Obtener los datos de la GUI\n\t\t\t\n\t\t\tvar input_blocksize : number = Number($(\"#config_blocksize\").val());\n\t\t\tvar input_nblocks : number = Number($(\"#config_nblocks\").val());\n\t\t\tvar input_nvias : number = Number($(\"#config_nvias\").val());\t\n\t\t\t\t\t\n\t\t\tvar input_asociatividad : string = $(\"#config_tipoasociatividad\").val();\n\t\t\tvar input_algoritmo : string = $(\"#config_algoritmo\").val();\n\t\t\tvar input_addressing : string = $(\"#config_addressing\").val();\n\t\t\t\n\t\t\t// No puede haber mas bloques que vias, se cambia\n\t\t\tif(input_nvias > input_nblocks){\n\t\t\t\t$(\"#config_nvias\").val(input_nblocks.toString());\n\t\t\t\tinput_nvias = input_nblocks;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Validar cada uno\n\t\t\n\t\t\tif(!numeroCorrecto(input_blocksize)){\n\t\t\t\tmostrarError(\"Tamaño de bloque no es correcto. Debe ser numero entero, potencia de 2.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!numeroCorrecto(input_nblocks)){\n\t\t\t\tmostrarError(\"Numero de bloques no es correcto. Debe ser numero entero, potencia de 2.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(tipoAsociatividad == \"sa\" && !numeroCorrecto(input_nvias)){\n\t\t\t\tmostrarError(\"Numero de vias no es correcto. Debe ser numero entero, potencia de 2.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_asociatividad == \"md\" || input_asociatividad == \"sa\" || input_asociatividad == \"fa\")){\n\t\t\t\tmostrarError(\"Asociatividad incorrecta.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_algoritmo == \"lru\" || input_algoritmo == \"mru\" || input_algoritmo == \"random\")){\n\t\t\t\tmostrarError(\"Algoritmo incorrecto.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_addressing == \"w\" || input_addressing == \"b\")){\n\t\t\t\tmostrarError(\"Tipo de addressing incorrecto.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\n\t\t\t// Si los datos de la GUI son correctos, se asignan a las variables del programa\n\t\t\t\n\t\t\tblocksize = input_blocksize;\n\t\t\tnblocks = input_nblocks;\n\t\t\tnvias = input_nvias;\n\t\t\ttipoAsociatividad = input_asociatividad;\n\t\t\talgoritmo = input_algoritmo;\n\t\t\taddressing = input_addressing;\n\t\t\t\n\t\t\t// Para asociatividades distintas, se habilitan o deshabilitan algunos campos\n\t\t\t\n\t\t\tif(tipoAsociatividad == \"md\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', true);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', true);\n\t\t\t\t// Actualizar automaticamente el numero de vias\n\t\t\t\tnvias = 1;\n\t\t\t\t\n\t\t\t} else if(tipoAsociatividad == \"sa\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', false);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', false);\n\t\t\t\t// se deja lo que ingreso el usuario\n\t\t\t\t// nvias = input_nvias;\n\t\t\t\t\n\t\t\t} else if(tipoAsociatividad == \"fa\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', true);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', false);\n\t\t\t\t// Actualizar automaticamente el numero de vias\n\t\t\t\tnvias = nblocks;\n\t\t\t}\n\t\t\t\n\t\t\t// Cambiar el input de forma automatica\n\t\t\t$(\"#config_nvias\").val(nvias.toString());\n\t\t\t\n\t\t\t// Mostrar informacion (no input de texto)\n\t\t\t$(\"#info_nsets\").text((nblocks / nvias).toString());\t\t\t\t\t\t\t\n\t\t\t$(\"#info_cachesize\").text((nblocks * blocksize * 4) + \" bytes (\"+(nblocks * blocksize)+\" palabras)\");\n\t\t\t\n\t\t\tmostrarError(\"\");\n\t\t\t\n\t\t\treturn true;\t\t\t\n\t\t}\t\t","/// <reference path=\"jquery.d.ts\"/>\n\"use strict\";\nvar algoritmoReemplazo;\n(function (algoritmoReemplazo) {\n    algoritmoReemplazo[algoritmoReemplazo[\"LRU\"] = 0] = \"LRU\";\n    algoritmoReemplazo[algoritmoReemplazo[\"MRU\"] = 1] = \"MRU\";\n    algoritmoReemplazo[algoritmoReemplazo[\"RANDOM\"] = 2] = \"RANDOM\";\n})(algoritmoReemplazo || (algoritmoReemplazo = {}));\nvar tipoDireccion;\n(function (tipoDireccion) {\n    tipoDireccion[tipoDireccion[\"BYTE\"] = 0] = \"BYTE\";\n    tipoDireccion[tipoDireccion[\"WORD\"] = 1] = \"WORD\";\n})(tipoDireccion || (tipoDireccion = {}));\nvar cacheEstado;\n(function (cacheEstado) {\n    cacheEstado[cacheEstado[\"HIT\"] = 0] = \"HIT\";\n    cacheEstado[cacheEstado[\"MISS\"] = 1] = \"MISS\";\n})(cacheEstado || (cacheEstado = {}));\nvar Cache = (function () {\n    function Cache() {\n    }\n    Object.defineProperty(Cache.prototype, \"hitCount\", {\n        get: function () {\n            return this._cacheHitCuenta;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"missCount\", {\n        get: function () {\n            return this._cacheMissCuenta;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"hitRate\", {\n        get: function () {\n            var total;\n            var hitPorcentaje;\n            total = this.hitCount + this.missCount;\n            hitPorcentaje = this.hitCount / total;\n            return Math.round(hitPorcentaje * 10000) / 100;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"numSets\", {\n        get: function () {\n            return this._nBlocks / this._setSize;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"offsetTotal\", {\n        // No entrega el numbero de bits que tiene el offset, si no\n        // el numero por el cual el numero debe ser dividido, para encontrar\n        // tag + indice (eliminar el offset)\n        get: function () {\n            if (this._tipoDireccion == tipoDireccion.BYTE) {\n                return this._blockSize * 4;\n            }\n            return this._blockSize;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"bitsOffset\", {\n        // Numero de bits del offset\n        get: function () {\n            // Es necesario restarle 1 porque, por ejemplo si hay 4 palabras por bloque\n            // el numero binario es 100, es decir 4. Pero se pueden hacer cuatro combinaciones\n            // con solo 2 bits, 00 01 10 11, por lo tanto no es necesario 3 bits, si no 2.\n            return this.offsetTotal.toString(2).length - 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Cache.prototype, \"bitsIndice\", {\n        // Obtiene la cantidad de bits necesarias para el indice\n        get: function () {\n            return this.numSets.toString(2).length - 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Interfaz con la GUI, recibe la configuracion\n    Cache.prototype.configurar = function (blocksize, nblocks, nvias, algoritmo, tipoAsociatividad, addressing) {\n        this._blockSize = blocksize;\n        this._nBlocks = nblocks;\n        // Algoritmo\n        if (algoritmo == \"lru\")\n            this._algoritmoReemplazo = algoritmoReemplazo.LRU;\n        else if (algoritmo == \"mru\")\n            this._algoritmoReemplazo = algoritmoReemplazo.MRU;\n        else if (algoritmo == \"random\")\n            this._algoritmoReemplazo = algoritmoReemplazo.RANDOM;\n        // Addressing\n        if (addressing == \"b\")\n            this._tipoDireccion = tipoDireccion.BYTE;\n        else\n            this._tipoDireccion = tipoDireccion.WORD;\n        // Mapeo directo\n        if (tipoAsociatividad == \"md\") {\n            this._setSize = 1;\n        }\n        else if (tipoAsociatividad == \"sa\") {\n            this._setSize = nvias;\n        }\n        else if (tipoAsociatividad == \"fa\") {\n            this._setSize = this._nBlocks;\n        }\n    };\n    Cache.prototype.procesarDirecciones = function (direcciones) {\n        var i;\n        var j;\n        var resultado = \"\";\n        // Numero de bits necesarios para poder mostrar por pantalla\n        // la direccion mas larga del conjunto\n        var bitsNecesarios = this.encontrarCantidadDeBitsNecesarias(direcciones);\n        // Numero de bloque de la direccion leida\n        var numBloque;\n        // Hacia donde mapea el bloque leido\n        var mapea;\n        // Aca se almacena la tabla\n        var sets;\n        // Obtener la palabra leida (si es por WORD, es la misma direccion)\n        // si es por BYTE hay que cambiarlo\n        var palabra;\n        // El estado del cache, hit o miss?\n        var estadohitmiss;\n        // Reiniciar el cache\n        this._cacheHitCuenta = 0;\n        this._cacheMissCuenta = 0;\n        // Crear sets\n        sets = new Array(this.numSets);\n        // Cada set tiene SET SIZE bloques\n        for (i = 0; i < this.numSets; i++) {\n            sets[i] = new Array(this._setSize);\n        }\n        // Hacer que sean todos -1\n        for (i = 0; i < this.numSets; i++) {\n            for (j = 0; j < this._setSize; j++) {\n                sets[i][j] = -1;\n            }\n        }\n        resultado = \"<table class=\\\"tablaCacheHitMiss\\\">\";\n        // Crear las cabeceras de la tabla\n        resultado += \"<tr>\";\n        resultado += \"<th class=\\\"noset\\\"> </th>\";\n        resultado += \"<th class=\\\"noset\\\">#</th>\";\n        resultado += \"<th class=\\\"noset\\\">direccion</th>\";\n        resultado += \"<th class=\\\"noset\\\">binario <small>(tag indice offset)</small</th>\";\n        resultado += \"<th class=\\\"noset\\\">bloque #</th>\";\n        for (i = 0; i < this.numSets; i++) {\n            resultado += \"<th>set \" + i + \"</th>\";\n        }\n        resultado += \"</tr>\";\n        // Leer todas las direcciones\n        for (i = 0; i < direcciones.length; i++) {\n            palabra = direcciones[i];\n            // La palabra se encuentra en el bloque\n            numBloque = Math.floor(palabra / this.offsetTotal);\n            // El bloque mapea a\n            mapea = numBloque % this.numSets;\n            // Ver si el bloque ya esta en cache\n            if (this.bloqueEstaEnSet(sets[mapea], numBloque)) {\n                // Esta en cache\n                // Hay que reordenar\n                this.correrBloqueHastaMasReciente(sets[mapea], numBloque);\n                this._cacheHitCuenta++;\n                estadohitmiss = cacheEstado.HIT;\n            }\n            else {\n                // No esta en cache\n                // Lo agrega siempre al final\n                this.agregarBloqueASet(sets[mapea], numBloque);\n                this._cacheMissCuenta++;\n                estadohitmiss = cacheEstado.MISS;\n            }\n            resultado += this.obtenerFilaCacheActual(sets, estadohitmiss, direcciones[i], numBloque, i, bitsNecesarios);\n        }\n        resultado += \"</table>\";\n        return resultado;\n    };\n    // Dada un arreglo de direcciones, encuentra el numero de bits necesarios\n    // para poder representar en binario, la direccion mas larga del arreglo\n    Cache.prototype.encontrarCantidadDeBitsNecesarias = function (dir) {\n        var max = 0;\n        var i;\n        for (i = 0; i < dir.length; i++) {\n            if (dir[i] > max) {\n                max = dir[i];\n            }\n        }\n        return max.toString(2).length;\n    };\n    // Dado una direccion numerica, la convierte en binario, y ademas\n    // separa la string (usando espacios) en tag, indice y offset\n    Cache.prototype.rellenarBinCerosYDividir = function (num, max) {\n        var resultado = num.toString(2);\n        var tag = \"\";\n        var indice = \"\";\n        var offset = \"\";\n        var i;\n        var cont;\n        // Agregar ceros hasta que se complete el tamano esperado\n        while (resultado.length < max) {\n            resultado = \"0\" + resultado;\n        }\n        // Ir agregando los digitos. En algunos casos podria ser que la\n        // string mas larga, tiene menos digitos que los digitos del\n        // offset e indice, en ese caso serian puros undefined,\n        // por eso en caso que sea undefined, le agrego un 0.\t\t\n        // Obtener el offset\n        for (cont = 0, i = resultado.length - 1; cont < this.bitsOffset; cont++, i--) {\n            if (resultado[i] == undefined) {\n                offset = \"0\" + offset;\n            }\n            else {\n                offset = resultado[i] + offset;\n            }\n        }\n        // Obtener el indice\n        for (cont = 0; cont < this.bitsIndice; cont++, i--) {\n            if (resultado[i] == undefined) {\n                indice = \"0\" + indice;\n            }\n            else {\n                indice = resultado[i] + indice;\n            }\n        }\n        // Obtener el tag\n        for (; i > -1; i--) {\n            if (resultado[i] == undefined) {\n                tag = \"0\" + tag;\n            }\n            else {\n                tag = resultado[i] + tag;\n            }\n        }\n        // Si el tag no tiene digitos, entonces colocarle algunos ceros\n        if (tag.length == 0) {\n            tag = \"0000\";\n        }\n        return tag + \"&nbsp;\" + indice + \"&nbsp;\" + offset;\n    };\n    // Entrega el estado de cache en un determinado momento\n    Cache.prototype.obtenerFilaCacheActual = function (sets, estadohitmiss, direccion, numBloque, numeroAcceso, bitsNecesarios) {\n        var i;\n        var j;\n        var cacheFila;\n        // Agregar el estado (hit/miss)\t\t\t\n        if (estadohitmiss == cacheEstado.HIT) {\n            cacheFila = \"<tr class=\\\"hit\\\"><td>H</td>\";\n        }\n        else {\n            cacheFila = \"<tr class=\\\"miss\\\"><td>M</td>\";\n        }\n        // Numero de acceso\n        cacheFila += \"<td>\" + (numeroAcceso + 1) + \"</td>\";\n        // Colocar la direccion (decimal)\n        cacheFila += \"<td>\" + direccion + \"</td>\";\n        // Direccion (binario)\n        cacheFila += \"<td>\" + this.rellenarBinCerosYDividir(direccion, bitsNecesarios) + \"</td>\";\n        // A que bloque pertenece\n        cacheFila += \"<td>\" + numBloque + \"</td>\";\n        // set[num set][num bloque]\n        for (i = 0; i < this.numSets; i++) {\n            cacheFila += \"<td>\";\n            for (j = 0; j < this._setSize; j++) {\n                if (sets[i][j] != -1) {\n                    cacheFila += sets[i][j] + \" \";\n                }\n            }\n            cacheFila += \"</td>\";\n        }\n        cacheFila += \"</tr>\";\n        return cacheFila;\n    };\n    Cache.prototype.correrBloqueHastaMasReciente = function (set, bloque) {\n        var i;\n        var cuantosBloquesTieneSet = this.cuantosBloquesTieneSet(set);\n        i = 0;\n        while (true) {\n            if (set[i] == bloque)\n                break;\n            i++;\n        }\n        for (; i < cuantosBloquesTieneSet - 1; i++) {\n            set[i] = set[i + 1];\n        }\n        // Agregar bloque nuevo\n        set[cuantosBloquesTieneSet - 1] = bloque;\n    };\n    Cache.prototype.cuantosBloquesTieneSet = function (set) {\n        var resultado;\n        var i;\n        resultado = 0;\n        for (i = 0; i < this._setSize; i++) {\n            if (set[i] == -1) {\n                break;\n            }\n            else {\n                resultado++;\n            }\n        }\n        return resultado;\n    };\n    // Lo agrega segun algoritmo\n    Cache.prototype.agregarBloqueASet = function (set, bloque) {\n        var cuantosBloquesTieneSet = this.cuantosBloquesTieneSet(set);\n        // Si no esta lleno el set, simplemente se agrega al final\n        if (cuantosBloquesTieneSet < this._setSize) {\n            set[cuantosBloquesTieneSet] = bloque;\n            return;\n        }\n        // Esta lleno\n        switch (this._algoritmoReemplazo) {\n            case algoritmoReemplazo.LRU:\n                // El primero es el mas antiguo\n                var i;\n                for (i = 0; i < this._setSize - 1; i++) {\n                    set[i] = set[i + 1];\n                }\n                // Agregar bloque nuevo al final\n                set[this._setSize - 1] = bloque;\n                break;\n            case algoritmoReemplazo.MRU:\n                // El ultimo es el mas reciente\n                set[this._setSize - 1] = bloque;\n                break;\n            case algoritmoReemplazo.RANDOM:\n                var rand = Math.floor(Math.random() * this._setSize);\n                set[rand] = bloque;\n                break;\n        }\n    };\n    Cache.prototype.bloqueEstaEnSet = function (set, bloque) {\n        var i;\n        for (i = 0; i < this._setSize; i++) {\n            if (set[i] == bloque) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Cache;\n}());\n/// <reference path=\"jquery.d.ts\"/>\nvar transpiladorMips;\n(function (transpiladorMips) {\n    function hexEncode(num) {\n        return \"0x\" + num.toString(16);\n    }\n    transpiladorMips.hexEncode = hexEncode;\n    // A partir de direcciones de memoria, genera un codigo MIPS\n    function obtenerCodigoMips(direcciones, tipoDireccionamiento) {\n        var i;\n        var base = 0x10040000;\n        var resultado = \"\";\n        if (tipoDireccionamiento == \"b\") {\n            for (i = 0; i < direcciones.length; i++)\n                resultado += \"lb $t0, \" + hexEncode(base + direcciones[i]) + \"\\n\";\n        }\n        else {\n            for (i = 0; i < direcciones.length; i++)\n                resultado += \"lw $t0, \" + hexEncode(base + (direcciones[i] * 4)) + \"\\n\";\n        }\n        $(\"#tablaCacheResultado\").html(resultado);\n        return resultado;\n    }\n    transpiladorMips.obtenerCodigoMips = obtenerCodigoMips;\n})(transpiladorMips || (transpiladorMips = {}));\n/// <reference path=\"jquery.d.ts\"/>\n/// <reference path=\"cache.ts\"/>\n/// <reference path=\"transpiladorMips.ts\"/>\nvar blocksize;\nvar nblocks;\nvar nvias;\nvar algoritmo;\nvar tipoAsociatividad;\nvar addressing;\nvar cache;\n/*\n*\n*\tSe ejecuta al cargar la pagina\n*\n*/\n$(document).ready(function () {\n    document.title = \"Organic Cache Simulator\";\n    // Configuracion inicial\n    $(\"#config_blocksize\").val((4).toString());\n    $(\"#config_nblocks\").val((16).toString());\n    $(\"#config_nvias\").val((4).toString());\n    validarConfiguracion();\n    cache = new Cache();\n    // Evento mouse\n    $(\"#btn_procesar\").click(function () {\n        procesarDirecciones();\n    });\n});\nfunction isPowerOfTwo(x) {\n    while (((x % 2) == 0) && x > 1)\n        x /= 2;\n    return (x == 1);\n}\nfunction numeroCorrecto(num) {\n    if (isPowerOfTwo(num))\n        return true;\n}\nfunction mostrarError(text) {\n    $(\"#span_error\").text(text);\n}\nfunction procesarDirecciones() {\n    var direcciones;\n    var tablaResultado;\n    // Primero realizar las validaciones de la configuracion de cache\n    if (!validarConfiguracion()) {\n        return;\n    }\n    // Validar direcciones\n    direcciones = crearArregloDirecciones();\n    if (direcciones == null) {\n        mostrarError(\"Ingresar direcciones correctamente\");\n        return;\n    }\n    // Configurar cache\n    cache.configurar(blocksize, nblocks, nvias, algoritmo, tipoAsociatividad, addressing);\n    // Obtener tabla cronologica de resultados\n    tablaResultado = cache.procesarDirecciones(direcciones);\n    // Obtener codigo mars\t\t\t\n    $(\"#textarea_codigomars\").html(transpiladorMips.obtenerCodigoMips(direcciones, addressing));\n    // Mostrar tabla\n    $(\"#tablaCacheResultado\").html(tablaResultado);\n    // Mostrar cuenta hit y miss\n    $(\"#hitMissRate\").html(\"<p>Hits: <b>\" + cache.hitCount + \"</b></p><p>Miss: <b>\" + cache.missCount + \"</b></p><p>Hit rate: <b>\" + cache.hitRate + \"%</b></p>\");\n    // Muestra cuantos bits necesita el indice y offset.\n    $(\"#bitsDireccion\").html(\"<p>Bits indice: <b>\" + cache.bitsIndice + \"</b></p><p>Bits offset: <b>\" + cache.bitsOffset + \"</b></p>\");\n    // Desocultar resultados\n    $(\"#todosResultados\").show();\n}\nfunction crearArregloDirecciones() {\n    // Todo lo que no es numero, transformarlo a espacio\n    var arregloDirecciones;\n    var arregloSplit;\n    var i;\n    var textoProcesado = $(\"#textarea_direcciones\").val().replace(/[^0-9]+/g, \" \");\n    // Eliminar los espacios de sobra\n    textoProcesado = textoProcesado.trim();\n    // Si no hay texto, retornar null\n    if (textoProcesado.length == 0) {\n        return null;\n    }\n    arregloSplit = textoProcesado.split(\" \");\n    // Crear arreglo numerico\n    arregloDirecciones = new Array(arregloSplit.length);\n    // Convertir a numeros\n    for (i = 0; i < arregloSplit.length; i++) {\n        arregloDirecciones[i] = Number(arregloSplit[i]);\n    }\n    // Si hay texto, retornar el arreglo de numeros\n    return arregloDirecciones;\n}\nfunction validarConfiguracion() {\n    // Obtener los datos de la GUI\n    var input_blocksize = Number($(\"#config_blocksize\").val());\n    var input_nblocks = Number($(\"#config_nblocks\").val());\n    var input_nvias = Number($(\"#config_nvias\").val());\n    var input_asociatividad = $(\"#config_tipoasociatividad\").val();\n    var input_algoritmo = $(\"#config_algoritmo\").val();\n    var input_addressing = $(\"#config_addressing\").val();\n    // No puede haber mas bloques que vias, se cambia\n    if (input_nvias > input_nblocks) {\n        $(\"#config_nvias\").val(input_nblocks.toString());\n        input_nvias = input_nblocks;\n    }\n    // Validar cada uno\n    if (!numeroCorrecto(input_blocksize)) {\n        mostrarError(\"Tamaño de bloque no es correcto. Debe ser numero entero, potencia de 2.\");\n        return false;\n    }\n    if (!numeroCorrecto(input_nblocks)) {\n        mostrarError(\"Numero de bloques no es correcto. Debe ser numero entero, potencia de 2.\");\n        return false;\n    }\n    if (tipoAsociatividad == \"sa\" && !numeroCorrecto(input_nvias)) {\n        mostrarError(\"Numero de vias no es correcto. Debe ser numero entero, potencia de 2.\");\n        return false;\n    }\n    if (!(input_asociatividad == \"md\" || input_asociatividad == \"sa\" || input_asociatividad == \"fa\")) {\n        mostrarError(\"Asociatividad incorrecta.\");\n        return false;\n    }\n    if (!(input_algoritmo == \"lru\" || input_algoritmo == \"mru\" || input_algoritmo == \"random\")) {\n        mostrarError(\"Algoritmo incorrecto.\");\n        return false;\n    }\n    if (!(input_addressing == \"w\" || input_addressing == \"b\")) {\n        mostrarError(\"Tipo de addressing incorrecto.\");\n        return false;\n    }\n    // Si los datos de la GUI son correctos, se asignan a las variables del programa\n    blocksize = input_blocksize;\n    nblocks = input_nblocks;\n    nvias = input_nvias;\n    tipoAsociatividad = input_asociatividad;\n    algoritmo = input_algoritmo;\n    addressing = input_addressing;\n    // Para asociatividades distintas, se habilitan o deshabilitan algunos campos\n    if (tipoAsociatividad == \"md\") {\n        $(\"#config_nvias\").prop('disabled', true);\n        $(\"#config_algoritmo\").prop('disabled', true);\n        // Actualizar automaticamente el numero de vias\n        nvias = 1;\n    }\n    else if (tipoAsociatividad == \"sa\") {\n        $(\"#config_nvias\").prop('disabled', false);\n        $(\"#config_algoritmo\").prop('disabled', false);\n    }\n    else if (tipoAsociatividad == \"fa\") {\n        $(\"#config_nvias\").prop('disabled', true);\n        $(\"#config_algoritmo\").prop('disabled', false);\n        // Actualizar automaticamente el numero de vias\n        nvias = nblocks;\n    }\n    // Cambiar el input de forma automatica\n    $(\"#config_nvias\").val(nvias.toString());\n    // Mostrar informacion (no input de texto)\n    $(\"#info_nsets\").text((nblocks / nvias).toString());\n    $(\"#info_cachesize\").text((nblocks * blocksize * 4) + \" bytes (\" + (nblocks * blocksize) + \" palabras)\");\n    mostrarError(\"\");\n    return true;\n}\n","/// <reference path=\"jquery.d.ts\"/>\nnamespace transpiladorMips {\t\t\n\texport function hexEncode(num : number) : string{\n\t\treturn \"0x\"+num.toString(16);\n\t}\t\n\t\n\t// A partir de direcciones de memoria, genera un codigo MIPS\n    export function obtenerCodigoMips(direcciones:number[], tipoDireccionamiento:string) {\t\t\n\t\tvar i : number;\n\t\tvar base : number = 0x10040000;\n\t\tvar resultado : string = \"\";\n\t\t\n\t\tif(tipoDireccionamiento == \"b\"){\n\t\t\tfor(i=0; i<direcciones.length; i++)\n\t\t\t\tresultado += \"lb $t0, \"+hexEncode(base+direcciones[i])+\"\\n\";\n\t\t} else {\n\t\t\tfor(i=0; i<direcciones.length; i++)\n\t\t\t\tresultado += \"lw $t0, \"+hexEncode(base+(direcciones[i]*4))+\"\\n\";\n\t\t}\n\t\t$(\"#tablaCacheResultado\").html(resultado);\n\t\treturn resultado;\t\n\t}\n}"],"sourceRoot":"/source/"}