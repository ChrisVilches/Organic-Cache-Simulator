{"version":3,"sources":["src/ts/cacheSimulator.ts","src/ts/transpiladorMips.ts","src/ts/gui.ts"],"names":["algoritmoReemplazo","tipoDireccion","cacheEstado","transpiladorMips","blocksize","nblocks","nvias","algoritmo","tipoAsociatividad","addressing","cache","CacheSimulator","Object","defineProperty","prototype","this","_cacheHitCuenta","_cacheMissCuenta","total","hitCount","missCount","hitPorcentaje","Math","round","_nBlocks","_setSize","_tipoDireccion","BYTE","_blockSize","offsetTotal","toString","length","numSets","configurar","_algoritmoReemplazo","LRU","MRU","RANDOM","WORD","procesarDirecciones","direcciones","i","j","numBloque","sets","estadohitmiss","resultado","bitsNecesarios","encontrarCantidadDeBitsNecesarias","Array","palabra","mapea","floor","bloqueEstaEnSet","correrBloqueHastaMasReciente","HIT","agregarBloqueASet","MISS","obtenerFilaCacheActual","dir","max","rellenarBinCerosYDividir","num","cont","tag","indice","offset","bitsOffset","undefined","bitsIndice","direccion","numeroAcceso","cacheFila","set","bloque","cuantosBloquesTieneSet","random","setRandomExample","values","ceil","$","val","join","isPowerOfTwo","x","numeroCorrecto","mostrarError","text","iconHtml","validarConfiguracion","crearArregloDirecciones","tablaResultado","html","obtenerCodigoMips","hitRate","show","arregloDirecciones","arregloSplit","textoProcesado","replace","trim","split","Number","input_blocksize","input_nblocks","input_nvias","input_asociatividad","input_algoritmo","input_addressing","prop","hexEncode","tipoDireccionamiento","base","document","ready","click"],"mappings":"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","file":"compiled.js","sourcesContent":["/// <reference path=\"jquery.d.ts\"/>\n\"use strict\";\n\nenum algoritmoReemplazo{\n\t\tLRU,\n\t\tMRU,\n\t\tRANDOM\n}\n\nenum tipoDireccion{\n\tBYTE,\n\tWORD\n}\n\nenum cacheEstado{\n\tHIT,\n\tMISS\n}\n\n// Cannot use \"Cache\" because it already exists.\nclass CacheSimulator{\t\n\n\tprivate _blockSize : number;\n\tprivate _nBlocks : number;\t\n\tprivate _setSize : number;\n\t\n\tprivate _algoritmoReemplazo : algoritmoReemplazo;\n\tprivate _tipoDireccion : tipoDireccion;\n\t\n\tprivate _cacheHitCuenta : number;\n\tprivate _cacheMissCuenta : number;\n\t\n\t\n\tconstructor(){\n\t\t\n\n\t}\n\t\n\tget hitCount() : number{\n\t\treturn this._cacheHitCuenta;\n\t}\n\t\n\tget missCount() : number{\n\t\treturn this._cacheMissCuenta;\n\t}\n\n\tget hitRate() : number{\n\t\tvar total : number;\n\t\tvar hitPorcentaje : number;\n\t\ttotal = this.hitCount + this.missCount;\n\t\thitPorcentaje = this.hitCount/total;\n\t\treturn Math.round(hitPorcentaje*10000)/100;\n\t}\n\t\n\t\n\tget numSets() : number{\n\t\treturn this._nBlocks/this._setSize;\n\t}\n\t\n\t// No entrega el numbero de bits que tiene el offset, si no\n\t// el numero por el cual el numero debe ser dividido, para encontrar\n\t// tag + indice (eliminar el offset)\n\tget offsetTotal() : number{\n\t\tif(this._tipoDireccion == tipoDireccion.BYTE){\n\t\t\treturn this._blockSize * 4;\n\t\t}\n\t\treturn this._blockSize;\n\t}\n\t\n\t\n\t// Numero de bits del offset\n\tget bitsOffset() : number{\n\t\t// Es necesario restarle 1 porque, por ejemplo si hay 4 palabras por bloque\n\t\t// el numero binario es 100, es decir 4. Pero se pueden hacer cuatro combinaciones\n\t\t// con solo 2 bits, 00 01 10 11, por lo tanto no es necesario 3 bits, si no 2.\n\t\treturn this.offsetTotal.toString(2).length - 1;\n\t}\n\t\t\n\t// Obtiene la cantidad de bits necesarias para el indice\n\tget bitsIndice() : number{\n\t\treturn this.numSets.toString(2).length - 1;\n\t}\n\t\n\t\n\t// Interfaz con la GUI, recibe la configuracion\n\tpublic configurar(blocksize : number, nblocks : number, nvias : number, algoritmo : string, tipoAsociatividad : string, addressing : string) : void{\n\t\tthis._blockSize = blocksize;\n\t\tthis._nBlocks = nblocks;\n\t\t\n\t\t// Algoritmo\n\t\tif(algoritmo == \"lru\") this._algoritmoReemplazo = algoritmoReemplazo.LRU;\n\t\telse if(algoritmo == \"mru\") this._algoritmoReemplazo = algoritmoReemplazo.MRU;\n\t\telse if(algoritmo == \"random\") this._algoritmoReemplazo = algoritmoReemplazo.RANDOM;\n\t\t\n\t\t// Addressing\n\t\tif(addressing == \"b\") this._tipoDireccion = tipoDireccion.BYTE;\n\t\telse this._tipoDireccion = tipoDireccion.WORD;\n\t\t\n\t\t// Mapeo directo\n\t\tif(tipoAsociatividad == \"md\") {\n\t\t\tthis._setSize = 1;\n\t\t} \n\t\t// Set asociativo\n\t\telse if(tipoAsociatividad == \"sa\") {\n\t\t\tthis._setSize = nvias;\n\t\t} \n\t\t// Full asociativo\n\t\telse if(tipoAsociatividad == \"fa\") {\n\t\t\tthis._setSize = this._nBlocks;\n\t\t}  \t\t\t\n\t}\n\t\n\t\n\tpublic procesarDirecciones(direcciones : number[]) : string{\n\t\tvar i : number;\n\t\tvar j : number;\n\t\tvar resultado : string = \"\";\n\t\t\n\t\t// Numero de bits necesarios para poder mostrar por pantalla\n\t\t// la direccion mas larga del conjunto\n\t\tvar bitsNecesarios : number = this.encontrarCantidadDeBitsNecesarias(direcciones);\t\n\t\t\t\t\n\t\t// Numero de bloque de la direccion leida\n\t\tvar numBloque : number;\n\t\t\n\t\t// Hacia donde mapea el bloque leido\n\t\tvar mapea : number;\n\t\t\n\t\t// Aca se almacena la tabla\n\t\tvar sets;\n\t\t\n\t\t// Obtener la palabra leida (si es por WORD, es la misma direccion)\n\t\t// si es por BYTE hay que cambiarlo\n\t\tvar palabra : number;\n\t\t\n\t\t// El estado del cache, hit o miss?\n\t\tvar estadohitmiss : cacheEstado;\n\t\t\n\t\t// Reiniciar el cache\n\t\tthis._cacheHitCuenta = 0;\n\t\tthis._cacheMissCuenta = 0;\n\t\t\n\n\t\t// Crear sets\n\t\t\n\t\tsets = new Array(this.numSets);\n\t\t\n\t\t// Cada set tiene SET SIZE bloques\n\t\t\n\t\tfor (i=0; i<this.numSets; i++){\n\t\t\tsets[i] = new Array(this._setSize);\n\t\t}\t\t\n\t\t\n\t\t// Hacer que sean todos -1\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tfor(j=0; j<this._setSize; j++){\n\t\t\t\tsets[i][j] = -1;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t\t\n\t\tresultado = \"<table class=\\\"tablaCacheHitMiss\\\">\";\n\t\t\n\t\t// Crear las cabeceras de la tabla\n\t\t\n\t\tresultado += \"<tr>\";\n\t\tresultado += \"<th class=\\\"noset\\\"> </th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">#</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">address</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">binary<br/><small>(tag index offset)</small</th>\";\n\t\tresultado += \"<th class=\\\"noset\\\">block #</th>\";\t\t\t\t\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tresultado += \"<th>set \"+i+\"</th>\";\n\t\t}\n\t\tresultado += \"</tr>\";\t\n\t\t\n\t\t\t\n\t\t// Leer todas las direcciones\n\t\t\n\t\tfor(i=0; i<direcciones.length; i++){\t\t\n\t\t\t\n\t\t\tpalabra = direcciones[i];\n\t\t\t\n\t\t\t// La palabra se encuentra en el bloque\n\t\t\tnumBloque = Math.floor(palabra/this.offsetTotal);\n\t\t\t\n\t\t\t// El bloque mapea a\n\t\t\tmapea = numBloque % this.numSets;\n\n\t\t\t// Ver si el bloque ya esta en cache\n\t\t\tif(this.bloqueEstaEnSet(sets[mapea], numBloque)){\n\t\t\t\t// Esta en cache\n\t\t\t\t// Hay que reordenar\n\t\t\t\tthis.correrBloqueHastaMasReciente(sets[mapea], numBloque);\n\t\t\t\tthis._cacheHitCuenta++;\n\t\t\t\testadohitmiss = cacheEstado.HIT;\n\t\t\t} else {\n\t\t\t\t// No esta en cache\n\t\t\t\t// Lo agrega siempre al final\n\t\t\t\tthis.agregarBloqueASet(sets[mapea], numBloque);\n\t\t\t\tthis._cacheMissCuenta++;\n\t\t\t\testadohitmiss = cacheEstado.MISS;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tresultado += this.obtenerFilaCacheActual(sets, estadohitmiss, direcciones[i], numBloque, i, bitsNecesarios);\n\t\t}\t\t\n\t\t\n\t\tresultado += \"</table>\";\n\t\t\n\t\treturn resultado;\n\t}\n\t\n\t\n\t// Dada un arreglo de direcciones, encuentra el numero de bits necesarios\n\t// para poder representar en binario, la direccion mas larga del arreglo\n\tprivate encontrarCantidadDeBitsNecesarias(dir : number[]) : number{\n\t\tvar max : number = 0;\n\t\tvar i : number;\n\t\t\n\t\tfor(i=0; i<dir.length; i++){\n\t\t\tif(dir[i] > max){\n\t\t\t\tmax = dir[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max.toString(2).length;\n\t\t\n\t}\n\t\n\t// Dado una direccion numerica, la convierte en binario, y ademas\n\t// separa la string (usando espacios) en tag, indice y offset\n\tprivate rellenarBinCerosYDividir(num : number, max : number) : string{\n\t\tvar resultado : string = num.toString(2);\n\t\tvar tag : string = \"\";\n\t\tvar indice : string = \"\";\n\t\tvar offset : string = \"\";\n\t\tvar i : number;\n\t\tvar cont : number;\n\t\t\n\t\t// Agregar ceros hasta que se complete el tamano esperado\n\t\twhile(resultado.length < max){\n\t\t\tresultado = \"0\"+resultado;\n\t\t}\n\t\t\n\t\t// Ir agregando los digitos. En algunos casos podria ser que la\n\t\t// string mas larga, tiene menos digitos que los digitos del\n\t\t// offset e indice, en ese caso serian puros undefined,\n\t\t// por eso en caso que sea undefined, le agrego un 0.\t\t\n\t\t\n\t\t// Obtener el offset\n\t\tfor(cont=0, i=resultado.length-1; cont < this.bitsOffset; cont++, i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\toffset = \"0\" + offset;\n\t\t\t} else {\n\t\t\t\toffset = resultado[i] + offset;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t// Obtener el indice\n\t\tfor(cont=0; cont < this.bitsIndice; cont++, i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\tindice = \"0\" + indice;\n\t\t\t} else {\n\t\t\t\tindice = resultado[i] + indice;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t// Obtener el tag\n\t\tfor(; i > -1; i--){\n\t\t\tif(resultado[i] == undefined){\n\t\t\t\ttag = \"0\" + tag;\n\t\t\t} else {\n\t\t\t\ttag = resultado[i] + tag;\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t// Si el tag no tiene digitos, entonces colocarle algunos ceros\n\t\tif(tag.length == 0) {\n\t\t\ttag = \"0000\";\n\t\t}\n\t\t\n\t\treturn tag + \"&nbsp;\" + indice + \"&nbsp;\" + offset;\t\n\t}\n\t\n\t\n\t// Entrega el estado de cache en un determinado momento\n\tprivate obtenerFilaCacheActual(sets, estadohitmiss : cacheEstado, direccion : number, numBloque : number, numeroAcceso : number, bitsNecesarios : number) : string{\n\t\tvar i:number;\n\t\tvar j:number;\n\t\tvar cacheFila:string;\t\t\n\t\t\n\t\t// Agregar el estado (hit/miss)\t\t\t\n\t\tif(estadohitmiss == cacheEstado.HIT){\n\t\t\tcacheFila = \"<tr class=\\\"hit\\\"><td>H</td>\";\n\t\t} else {\n\t\t\tcacheFila = \"<tr class=\\\"miss\\\"><td>M</td>\";\n\t\t}\n\t\t\t\n\t\t// Numero de acceso\n\t\tcacheFila += \"<td>\"+(numeroAcceso+1)+\"</td>\";\n\t\t\t\n\t\t// Colocar la direccion (decimal)\n\t\tcacheFila += \"<td>\"+direccion+\"</td>\";\n\t\t\n\t\t// Direccion (binario)\n\t\tcacheFila += \"<td>\"+this.rellenarBinCerosYDividir(direccion, bitsNecesarios)+\"</td>\";\n\t\t\n\t\t// A que bloque pertenece\n\t\tcacheFila += \"<td>\"+numBloque+\"</td>\";\n\t\t\n\t\t// set[num set][num bloque]\n\t\t\n\t\tfor(i=0; i<this.numSets; i++){\n\t\t\tcacheFila += \"<td>\";\n\t\t\tfor(j=0; j<this._setSize; j++){\n\t\t\t\tif(sets[i][j] != -1){\n\t\t\t\t\tcacheFila += sets[i][j]+\" \";\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tcacheFila += \"</td>\";\n\t\t}\n\t\t\n\t\tcacheFila += \"</tr>\";\n\t\t\n\t\treturn cacheFila;\n\t}\n\t\n\n\t\n\tprivate correrBloqueHastaMasReciente(set, bloque : number) : void{\n\t\tvar i : number;\n\t\tvar cuantosBloquesTieneSet : number = this.cuantosBloquesTieneSet(set);\n\t\t\n\t\ti = 0;\n\t\twhile(true){\t\t\t\n\t\t\tif(set[i] == bloque) break;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(; i<cuantosBloquesTieneSet-1; i++){\n\t\t\tset[i] = set[i+1];\n\t\t}\n\t\t// Agregar bloque nuevo\n\t\tset[cuantosBloquesTieneSet-1] = bloque;\t\t\n\t}\n\t\n\t\n\tprivate cuantosBloquesTieneSet(set):number{\n\t\tvar resultado : number;\n\t\tvar i : number;\n\t\tresultado = 0;\n\t\t\n\t\tfor(i=0; i<this._setSize; i++){\n\t\t\tif(set[i] == -1){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tresultado++;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treturn resultado;\n\t}\n\t\n\t\n\t// Lo agrega segun algoritmo\n\tprivate agregarBloqueASet(set, bloque : number) : void{\n\t\t\n\t\tvar cuantosBloquesTieneSet : number = this.cuantosBloquesTieneSet(set);\n\t\t\n\t\t// Si no esta lleno el set, simplemente se agrega al final\n\t\t\n\t\tif(cuantosBloquesTieneSet < this._setSize){\n\t\t\tset[cuantosBloquesTieneSet] = bloque;\n\t\t\treturn;\t\n\t\t}\n\t\t\n\t\t// Esta lleno\n\n\t\tswitch(this._algoritmoReemplazo){\n\t\t\tcase algoritmoReemplazo.LRU:\n\t\t\t\t// El primero es el mas antiguo\n\t\t\t\tvar i : number;\n\t\t\t\tfor(i=0; i<this._setSize-1; i++){\n\t\t\t\t\tset[i] = set[i+1];\n\t\t\t\t}\n\t\t\t\t// Agregar bloque nuevo al final\n\t\t\t\tset[this._setSize-1] = bloque;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase algoritmoReemplazo.MRU:\n\t\t\t\t// El ultimo es el mas reciente\n\t\t\t\tset[this._setSize-1] = bloque;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase algoritmoReemplazo.RANDOM:\n\t\t\t\tvar rand = Math.floor(Math.random()*this._setSize);\n\t\t\t\tset[rand] = bloque;\t\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n\tprivate bloqueEstaEnSet(set, bloque : number):Boolean{\n\t\tvar i : number;\n\t\tfor(i=0; i<this._setSize; i++){\n\t\t\tif(set[i] == bloque){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n}","/// <reference path=\"jquery.d.ts\"/>\nnamespace transpiladorMips {\t\t\n\texport function hexEncode(num : number) : string{\n\t\treturn \"0x\"+num.toString(16);\n\t}\t\n\t\n\t// A partir de direcciones de memoria, genera un codigo MIPS\n    export function obtenerCodigoMips(direcciones:number[], tipoDireccionamiento:string) {\t\t\n\t\tvar i : number;\n\t\tvar base : number = 0x10040000;\n\t\tvar resultado : string = \"\";\n\t\t\n\t\tif(tipoDireccionamiento == \"b\"){\n\t\t\tfor(i=0; i<direcciones.length; i++)\n\t\t\t\tresultado += \"lb $t0, \"+hexEncode(base+direcciones[i])+\"\\n\";\n\t\t} else {\n\t\t\tfor(i=0; i<direcciones.length; i++)\n\t\t\t\tresultado += \"lw $t0, \"+hexEncode(base+(direcciones[i]*4))+\"\\n\";\n\t\t}\n\t\t$(\"#tablaCacheResultado\").html(resultado);\n\t\treturn resultado;\t\n\t}\n}","\t\t/// <reference path=\"jquery.d.ts\"/>\n\t\t/// <reference path=\"cacheSimulator.ts\"/>\n        /// <reference path=\"transpiladorMips.ts\"/>\n\n\t\tvar blocksize : number;\n\t\tvar nblocks : number;\n\t\tvar nvias : number;\n\t\t\n\t\tvar algoritmo : string;\n\t\tvar tipoAsociatividad : string;\n\t\tvar addressing : string;\n\t\t\n\t\tvar cache : CacheSimulator;\n\t\t\n\t\t\n\t\t/*\n\t\t*\n\t\t*\tSe ejecuta al cargar la pagina\n\t\t*\n\t\t*/\n\t\t\n\t\t$(document).ready(function(){\n\t\t\t// Configuracion inicial\n\t\t\t\n\t\t\t$(\"#config_blocksize\").val((4).toString());\n\t\t\t$(\"#config_nblocks\").val((16).toString());\n\t\t\t$(\"#config_nvias\").val((4).toString());\t\n\t\t\tvalidarConfiguracion();\t\n\t\t\t\n\t\t\tcache = new CacheSimulator();\t\n\t\t\t\n\t\t\t\n\t\t\t// Evento mouse\n\t\t\t\n\t\t\t$(\"#btn_procesar\").click(procesarDirecciones);\n\t\t\t$(\"#btn_random\").click(setRandomExample);\n\n\t\t\tsetRandomExample();\n\t\t});\n\t\t\n\t\t\n\t\t// Agrega un ejemplo aleatorio (lo ingresa en el textarea, y lo ejecuta).\n\t\tfunction setRandomExample() {\n\t\t\tconst rand = () => {\n\t\t\t\treturn Math.ceil(Math.random() * 100);\n\t\t\t}\n\n\t\t\tvar values = Array(30);\n\t\t\tfor(var i=0; i<values.length; i++){\n\t\t\t\tvalues[i] = rand();\n\t\t\t}\n\n\t\t\t$(\"#textarea_direcciones\").val(values.join(', '));\n\n\t\t\tprocesarDirecciones();\n\t\t}\n\t\t\n\t\tfunction isPowerOfTwo(x : number) : Boolean{\n\t\t\twhile (((x % 2) == 0) && x > 1)\n\t\t\t\tx /= 2;\n\t\t\treturn (x == 1);\n\t\t}\n\t\t\n\t\t\n\t\tfunction numeroCorrecto(num : number) : Boolean{\n\t\t\tif(isPowerOfTwo(num))\n\t\t\t\treturn true;\n\t\t}\t\t\n\t\t\n\t\t\n\t\tfunction mostrarError(text : string) : void{\n\t\t\t$(\"#span_error\").text(text);\n\t\t}\t\t\n\t\t\n\t\t\n\t\tfunction procesarDirecciones() : void{\n\t\t\tvar direcciones : number[];\n\t\t\tvar tablaResultado : string;\n\t\t\t\t\t\t\n\t\t\t// Primero realizar las validaciones de la configuracion de cache\n\t\t\tif(!validarConfiguracion()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Validar direcciones\n\t\t\tdirecciones = crearArregloDirecciones();\t\t\t\n\t\t\tif(direcciones == null){\n\t\t\t\tmostrarError(\"Enter addresses correctly.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Configurar cache\n\t\t\tcache.configurar(blocksize, nblocks, nvias, algoritmo, tipoAsociatividad, addressing);\t\t\t\n\t\t\t\n\t\t\t// Obtener tabla cronologica de resultados\n\t\t\ttablaResultado = cache.procesarDirecciones(direcciones);\n\t\t\t\n\t\t\t// Obtener codigo mars\t\t\t\n\t\t\t$(\"#textarea_codigomars\").html(transpiladorMips.obtenerCodigoMips(direcciones, addressing));\n\t\t\t\n\t\t\t// Mostrar tabla\n\t\t\t$(\"#tablaCacheResultado\").html(tablaResultado);\n\n\t\t\tvar iconHtml = \"<i class='fa fa-angle-right result-item-icon'></i>\";\n\t\t\t\n\t\t\t// Mostrar cuenta hit y miss\n\t\t\t$(\"#hitMissRate\").html(\"<p>\"+iconHtml+\"Hits: <b>\"+cache.hitCount+\"</b></p><p>\"+iconHtml+\"Miss: <b>\"+cache.missCount+\"</b></p><p>\"+iconHtml+\"Hit rate: <b>\"+cache.hitRate+\"%</b></p>\");\n\t\t\t\n\t\t\t// Muestra cuantos bits necesita el indice y offset.\n\t\t\t$(\"#bitsDireccion\").html(\"<p>\"+iconHtml+\"Index bits: <b>\"+cache.bitsIndice+\"</b></p><p>\"+iconHtml+\"Offset bits: <b>\"+cache.bitsOffset+\"</b></p>\");\n\t\t\t\n\t\t\t// Desocultar resultados\n\t\t\t$(\"#todosResultados\").show();\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfunction crearArregloDirecciones() : number[]{\t\n\t\t\t// Todo lo que no es numero, transformarlo a espacio\n\t\t\tvar arregloDirecciones : number[];\n\t\t\tvar arregloSplit : string[];\n\t\t\tvar i : number;\n\t\t\tvar textoProcesado : string = $(\"#textarea_direcciones\").val().toString().replace(/[^0-9]+/g, \" \");\n\t\t\t\n\t\t\t// Eliminar los espacios de sobra\n\t\t\ttextoProcesado = textoProcesado.trim();\n\t\t\t\n\t\t\t// Si no hay texto, retornar null\n\t\t\tif(textoProcesado.length == 0){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tarregloSplit = textoProcesado.split(\" \");\n\t\t\t\n\t\t\t// Crear arreglo numerico\n\t\t\tarregloDirecciones = new Array<number>(arregloSplit.length);\n\t\t\t\n\t\t\t// Convertir a numeros\n\t\t\tfor(i=0; i<arregloSplit.length; i++){\n\t\t\t\tarregloDirecciones[i] = Number(arregloSplit[i]);\n\t\t\t}\n\t\t\t\n\t\t\t// Si hay texto, retornar el arreglo de numeros\n\t\t\treturn arregloDirecciones\n\t\t}\n\t\t\n\t\t\n\t\tfunction validarConfiguracion() : Boolean{\t\t\t\n\t\t\t\t\t\t\n\t\t\t// Obtener los datos de la GUI\n\t\t\t\n\t\t\tvar input_blocksize : number = Number($(\"#config_blocksize\").val());\n\t\t\tvar input_nblocks : number = Number($(\"#config_nblocks\").val());\n\t\t\tvar input_nvias : number = Number($(\"#config_nvias\").val());\t\n\t\t\t\t\t\n\t\t\tvar input_asociatividad : string = $(\"#config_tipoasociatividad\").val().toString();\n\t\t\tvar input_algoritmo : string = $(\"#config_algoritmo\").val().toString();\n\t\t\tvar input_addressing : string = $(\"#config_addressing\").val().toString();\n\t\t\t\n\t\t\t// No puede haber mas bloques que vias, se cambia\n\t\t\tif(input_nvias > input_nblocks){\n\t\t\t\t$(\"#config_nvias\").val(input_nblocks.toString());\n\t\t\t\tinput_nvias = input_nblocks;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Validar cada uno\n\t\t\n\t\t\tif(!numeroCorrecto(input_blocksize)){\n\t\t\t\tmostrarError(\"Block size is incorrect. It must be a power of 2 integer.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!numeroCorrecto(input_nblocks)){\n\t\t\t\tmostrarError(\"Number of blocks is incorrect. It must be a power of 2 integer.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(tipoAsociatividad == \"sa\" && !numeroCorrecto(input_nvias)){\n\t\t\t\tmostrarError(\"Number of ways is incorrect. It must be a power of 2 integer.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_asociatividad == \"md\" || input_asociatividad == \"sa\" || input_asociatividad == \"fa\")){\n\t\t\t\tmostrarError(\"Incorrect associativity.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_algoritmo == \"lru\" || input_algoritmo == \"mru\" || input_algoritmo == \"random\")){\n\t\t\t\tmostrarError(\"Incorrect algorithm.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!(input_addressing == \"w\" || input_addressing == \"b\")){\n\t\t\t\tmostrarError(\"Incorrect addressing type.\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\n\t\t\t// Si los datos de la GUI son correctos, se asignan a las variables del programa\n\t\t\t\n\t\t\tblocksize = input_blocksize;\n\t\t\tnblocks = input_nblocks;\n\t\t\tnvias = input_nvias;\n\t\t\ttipoAsociatividad = input_asociatividad;\n\t\t\talgoritmo = input_algoritmo;\n\t\t\taddressing = input_addressing;\n\t\t\t\n\t\t\t// Para asociatividades distintas, se habilitan o deshabilitan algunos campos\n\t\t\t\n\t\t\tif(tipoAsociatividad == \"md\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', true);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', true);\n\t\t\t\t// Actualizar automaticamente el numero de vias\n\t\t\t\tnvias = 1;\n\t\t\t\t\n\t\t\t} else if(tipoAsociatividad == \"sa\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', false);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', false);\n\t\t\t\t// se deja lo que ingreso el usuario\n\t\t\t\t// nvias = input_nvias;\n\t\t\t\t\n\t\t\t} else if(tipoAsociatividad == \"fa\"){\n\t\t\t\t$(\"#config_nvias\").prop('disabled', true);\n\t\t\t\t$(\"#config_algoritmo\").prop('disabled', false);\n\t\t\t\t// Actualizar automaticamente el numero de vias\n\t\t\t\tnvias = nblocks;\n\t\t\t}\n\t\t\t\n\t\t\t// Cambiar el input de forma automatica\n\t\t\t$(\"#config_nvias\").val(nvias.toString());\n\t\t\t\n\t\t\t// Mostrar informacion (no input de texto)\n\t\t\t$(\"#info_nsets\").text((nblocks / nvias).toString());\t\t\t\t\t\t\t\n\t\t\t$(\"#info_cachesize\").text((nblocks * blocksize * 4) + \" bytes (\"+(nblocks * blocksize)+\" words)\");\n\t\t\t\n\t\t\tmostrarError(\"\");\n\t\t\t\n\t\t\treturn true;\t\t\t\n\t\t}\t\t"]}